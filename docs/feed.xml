<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://miere.observer/feed.xml" rel="self" type="application/atom+xml" /><link href="https://miere.observer/" rel="alternate" type="text/html" /><updated>2020-05-22T15:33:09+10:00</updated><id>https://miere.observer/feed.xml</id><title type="html">Miere’s Personal Observations</title><subtitle>Miere's Personal Observations</subtitle><entry><title type="html">Documenting Your Software Architecture</title><link href="https://miere.observer/engineering/2020/05/22/Documenting-Your-Software-Architecture.html" rel="alternate" type="text/html" title="Documenting Your Software Architecture" /><published>2020-05-22T00:00:00+10:00</published><updated>2020-05-22T00:00:00+10:00</updated><id>https://miere.observer/engineering/2020/05/22/Documenting-Your-Software-Architecture</id><content type="html" xml:base="https://miere.observer/engineering/2020/05/22/Documenting-Your-Software-Architecture.html">&lt;p&gt;In the 2000s we went from documenting every single class of our software to not at all. It was an attempt to increase the delivery pace, keeping the team away from tasks that, eventually, have to be remade once the software changes. As a side effect, scaling the team became a problem. The most notable one is the lack of autonomy from its members. Not only newcomers need special attention to get familiarized with the basics of their software (like building and running it), but they would still ask several questions until they understand how it works and how it solves the problem it was designed for.&lt;/p&gt;

&lt;p&gt;It is a known fact that designing new software requires meticulous planning, strict alignment between team members and keep them focused on the defined goal. Reducing the scope of your documentation to the software architecture might be a good starting point, as you probably don’t need to document every single class of your software to give them enough direction when they are coding. It relieves teams from frequently asked questions and forcing its members to stick with previous definitions unless a big change is necessary, and will let them focus on the business side of their projects.&lt;/p&gt;

&lt;p&gt;Unlike the lack of autonomy, lack of accountability plays a non-neglectable indirect impact on team performance. Let us assume that in a Software Development team we are going to face only three types of issues: bugs, business-related issues and architecture issues. While Developers are accountable for solving bugs, and Product Owners for business-related issues, even on teams where there’s a dedicated Software Architect nobody responds for the architectural problems the team faces. On first glance, it seems unfair to blame him for a problem that was introduced collectively by a multitude of reasons that happened together.&lt;/p&gt;

&lt;p&gt;In reality, once the team starts documenting their learnings and architectural decisions they will become more accountable from their architectural decisions. By being fully aware of the technical decisions made in the past and understanding the expected positive outcome it introduced, teams can be accountable for architecture issues on the software, erasing the grey zone between Architecture Decisions and Business Decisions.&lt;/p&gt;

&lt;h2 id=&quot;documenting-for-your-different-audiences&quot;&gt;Documenting for your different audiences&lt;/h2&gt;
&lt;p&gt;Documentation is a tool to transfer knowledge, to keep the team on the same page regarding &lt;strong&gt;what problem the software solves, how those problems were solved, what were the technical decisions that should be followed widely during the development, and how one can run the software and see it in action&lt;/strong&gt;. Having long essays written in an MS Word document or a Wiki page is not enough to efficiently convey the information to the team members.&lt;/p&gt;

&lt;p&gt;On &lt;a href=&quot;https://youtu.be/x2-rSnhpw0g&quot;&gt;his talk&lt;/a&gt; Visualising The Software Architecture, &lt;a href=&quot;https://simonbrown.je/&quot;&gt;Simon Brown&lt;/a&gt; stressed that “as your software have different audiences with different needs”. He means that you need different tools to cover how the different layers of our software work. Thus, along with his iconic C4Model - which will be discussed later - I have adopted a couple of simple-yet-powerful guidelines that helped me to contextualize whoever is maintaining our source code.&lt;/p&gt;

&lt;h2 id=&quot;the-source-code-guideline&quot;&gt;The Source Code Guideline&lt;/h2&gt;
&lt;p&gt;For the sake of productivity, the documentation should be started with the Source Code Guideline, which covers the basics concepts a developer might need to understand how the project source code is structured. A basic version of this document should answer the following questions a developer might have - although it can be enhanced with more topics whenever needed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;How to run the software locally?&lt;/li&gt;
  &lt;li&gt;How to run all automated tests locally?&lt;/li&gt;
  &lt;li&gt;How to package the software?&lt;/li&gt;
  &lt;li&gt;How to deploy the software?&lt;/li&gt;
  &lt;li&gt;How to edit the software?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bear in mind that long lists of commands can lead to reproducibility issues. So try to keep it as neat as possible, &lt;a href=&quot;https://miere.observer/engineering/2020/04/20/Producing-professional-deliverables.html#going-beyond-kents-simple-design&quot;&gt;automating it before documenting it&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote class=&quot;note&quot;&gt;
&lt;a href=&quot;https://gist.github.com/miere/cba07143f3f37c64fc0fa82a8e9179a6&quot;&gt;Here&lt;/a&gt; you can find a sample document that answers these questions with topics, making them easy to read.
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-architecture-decisions-guideline&quot;&gt;The Architecture Decisions Guideline&lt;/h2&gt;
&lt;p&gt;Next comes the Architecture Decisions Guideline, which complies of everything that might affect the daily routine of any contributor to your software. It should be straightforward and concise, not only pointing the exact direction one has to follow to contribute to the software, but also introducing them lessons learnt from the past and decision taken to avoid possible issues. It may contain:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An analytical list of problems, techniques and methodologies that should be avoided on the project.&lt;/li&gt;
  &lt;li&gt;A detailed process of how issues should be fixed and how new features should be introduced in the software. Make sure to state the tools involved in this process - e.g. Git branches.&lt;/li&gt;
  &lt;li&gt;A brief explanation of how new releases are rolled out to production.&lt;/li&gt;
  &lt;li&gt;An explanation of how quality is enforced before a release is closed.&lt;/li&gt;
  &lt;li&gt;What coding principles shall be applied otherwise the proposed modifications might be denied.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When to compose this document is a complex topic. Synergic teams are constantly aligned and might be on the same page right from the conception of the software, which would allow the team to postpone the document creation to a future moment. It’s desirable, though, to have it finished once the first stable version of the software is released. Its existence will be the backbone of any code review that might happen in the future. It will ensure that the quality the code base achieved will last long enough so developers can move to the next project with peace of mind.&lt;/p&gt;

&lt;blockquote class=&quot;note&quot;&gt;
&lt;a href=&quot;https://gist.github.com/miere/bcd10534a0c26f30b7e6d5234c4e903e&quot;&gt;Here&lt;/a&gt; you can find a sample document that exemplifies how it can be composed. This one, though, is a bit denser than the previous one as it was based on a previously written document taken from a previous customer.
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-c4model&quot;&gt;The C4Model&lt;/h2&gt;
&lt;p&gt;C4Model is probably the most pragmatic documentation model I’ve come across. Simon came with the idea to represent the different layers of software with diagrams. When he conceived it, he wanted us to experience a model that worked like maps: by zooming out you get more context you dive into more details, but when you zoom out to better understand in which context the software is running on.  According to the way he conceives it, any software can be described in four main layers, each of which is represented by one diagram:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;System Context Diagram&lt;/strong&gt; - Shows the software in question in the centre, identifying who works with it and what it depends on.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Containers Diagram&lt;/strong&gt; - Illustrates the overall shape of the architecture and a few technology choices.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Components Diagram&lt;/strong&gt; - Explains the logical components and their interactions within the component.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code Diagrams&lt;/strong&gt; - Explains component implementations in detail.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first three diagrams are his creations, all of which adopts simplistic notations to demonstrate how a particular piece of the system is working. Code Diagrams, on the other hand, are basically UML and he discourages us to adopt them as they tend to become outdated quite frequently. It is there in the case you have a specific need where documenting the source code itself is mandatory task.&lt;/p&gt;

&lt;p&gt;C4Model is &lt;a href=&quot;https://c4model.com/&quot;&gt;well documented on its website&lt;/a&gt;, with several years spent polishing it to reach this level of simplicity and organization. The beauty behind these diagrams lies in the fact we can pick our target audience, allowing us to choose when and who should be involved in the documentation process.&lt;/p&gt;</content><author><name></name></author><category term="engineering" /><summary type="html">In the 2000s we went from documenting every single class of our software to not at all. It was an attempt to increase the delivery pace, keeping the team away from tasks that, eventually, have to be remade once the software changes. As a side effect, scaling the team became a problem. The most notable one is the lack of autonomy from its members. Not only newcomers need special attention to get familiarized with the basics of their software (like building and running it), but they would still ask several questions until they understand how it works and how it solves the problem it was designed for.</summary></entry><entry><title type="html">Re: Ensuring backwards compatibility in distributed systems</title><link href="https://miere.observer/engineering/2020/05/20/Re-Ensuring-backwards-compatibility-in-distributed-systems.html" rel="alternate" type="text/html" title="Re: Ensuring backwards compatibility in distributed systems" /><published>2020-05-20T00:00:00+10:00</published><updated>2020-05-20T00:00:00+10:00</updated><id>https://miere.observer/engineering/2020/05/20/Re-Ensuring-backwards-compatibility-in-distributed-systems</id><content type="html" xml:base="https://miere.observer/engineering/2020/05/20/Re-Ensuring-backwards-compatibility-in-distributed-systems.html">&lt;p&gt;A few days ago, I spotted a blog post from StackOverflow that drew my attention: &lt;a href=&quot;https://stackoverflow.blog/2020/05/13/ensuring-backwards-compatibility-in-distributed-systems/&quot;&gt;Ensuring backwards compatibility in distributed systems&lt;/a&gt;. That is the sort of topic I love to consume as it gives me new insights and let me know how people are solving similar problems. The article was engagingly good and kept me focused on reading it until the end.&lt;/p&gt;

&lt;p&gt;I would like, though, to write a few remarks about a few definitions assumed in the article which, if taken by the book, are not strictly correct. The idea behind the following paragraphs is far from detracting the author or the post itself. StackOverflow has a massive audience and knowing the correct definition might help them to adopt the right technique for the right job.&lt;/p&gt;

&lt;h2 id=&quot;conditions-which-the-suggested-deployment-technique-works&quot;&gt;Conditions which the suggested deployment technique works&lt;/h2&gt;
&lt;p&gt;In the blog post, there is a topic about software deployment that covers a few important techniques that might be useful for developers to ensure backward compatibility between evolving versions of the same software.  The author emphasized, though, that they will “only work under two conditions”, one of them is applying it to a “brand new software projects”.&lt;/p&gt;

&lt;p&gt;Reading the article I couldn’t notice a single technique that could not be applied to old software. I had the opportunity to adopt those techniques myself in 2013 when I was hired by &lt;a href=&quot;https://www.ibratan.com.br/&quot;&gt;Ibratan&lt;/a&gt; to redesign their primary software. It was mainly written in C and COBOL and, by adopting a combination of &lt;a href=&quot;https://en.wikipedia.org/wiki/Feature_toggle&quot;&gt;Feature Toggle&lt;/a&gt; and &lt;a href=&quot;https://martinfowler.com/bliki/CanaryRelease.html&quot;&gt;Canary Deployment&lt;/a&gt;, I was able to fix some undesirable behaviours the software had and introduce a new API layer written in Java 8.&lt;/p&gt;

&lt;p&gt;Personally, there is no such thing as Old Project, or Legacy Software if you will. There are only Well Written Software and Poorly Written Software, and it is possible to adopt any technique you want in both cases. Arguably, you might see a greater benefit in adopting those techniques in a poorly written software as they usually demand more maintenance.&lt;/p&gt;

&lt;h2 id=&quot;canary-release-vs-bluegreen-deployment&quot;&gt;Canary Release vs Blue/Green Deployment&lt;/h2&gt;
&lt;p&gt;Perhaps this is not directly related to the blog post itself, but to a universal feeling that Canary Deployment and Blue/Green Deployment are the same things. Despite their similarities, it is important to distinguish them apart as they introduce different benefits to our deployment pipeline.&lt;/p&gt;

&lt;p&gt;The term &lt;strong&gt;Blue/Green Deployment&lt;/strong&gt; was first introduced &lt;a href=&quot;https://gitlab.com/snippets/1846041&quot;&gt;ages ago&lt;/a&gt;, having been carved by &lt;a href=&quot;http://dannorth.net&quot;&gt;Daniel Terhorst-North&lt;/a&gt; and &lt;a href=&quot;https://www.thoughtworks.com/profiles/jez-humble&quot;&gt;Jez Humble&lt;/a&gt; by early 2010s. The fundamental idea is to have two easily switchable environments to switch between, allowing the software to be pre-released and tested on a deployment environment similar to the production. Once considered stable, a switch mechanism takes place, redirecting user’s request traffic to the just deployed software.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://martinfowler.com/bliki/BlueGreenDeployment.html&quot;&gt;switch mechanism may vary&lt;/a&gt; depending on the business expectation (e.g. high availability SLAs) or different technical needs (e.g. run smoke tests before release) might you have. One of them is the Canary Release. It “is a technique to reduce the risk of introducing a new software version in production by slowly rolling out the change to a small subset of users before rolling it out to the entire infrastructure and making it available to everybody” &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;By introducing the ability to analyse the impact of the just-released software with real data coming from the production request stream, &lt;em&gt;Data Analysts&lt;/em&gt; and &lt;em&gt;Software Architects&lt;/em&gt; can measure the impact the new release will have, rolling it back if the results are not satisfactory. Blue/Green Deployment, on the other hand, is closely related to the deployment itself, therefore it focuses mostly on the technical side of it - namely high-availability and easy rollback.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;I’d like to stress that the richness of the blog post content should not be blurred away despite the two topics that I covered. Gather all the information needed to compose such post is no easy task and might take precious ours to compose and wrap it in a way that his audience might enjoy. Perhaps a few links in the original to an external content could be enough to clarify the points I’ve made here, although writing down a few paragraphs helped to keep my understanding of those concepts fresh.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://martinfowler.com/bliki/CanaryRelease.html&quot;&gt;Canary Release&lt;/a&gt; by &lt;a href=&quot;http://www.dtsato.com/blog/&quot;&gt;Danilo Sato&lt;/a&gt;. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">A few days ago, I spotted a blog post from StackOverflow that drew my attention: Ensuring backwards compatibility in distributed systems. That is the sort of topic I love to consume as it gives me new insights and let me know how people are solving similar problems. The article was engagingly good and kept me focused on reading it until the end.</summary></entry><entry><title type="html">Decomposing a Monolith</title><link href="https://miere.observer/engineering/2020/05/19/Decomposing-Monolith.html" rel="alternate" type="text/html" title="Decomposing a Monolith" /><published>2020-05-19T00:00:00+10:00</published><updated>2020-05-19T00:00:00+10:00</updated><id>https://miere.observer/engineering/2020/05/19/Decomposing-Monolith</id><content type="html" xml:base="https://miere.observer/engineering/2020/05/19/Decomposing-Monolith.html">&lt;header class=&quot;briefing&quot;&gt;
&lt;div class=&quot;video&quot;&gt;&lt;iframe class=&quot;video&quot; src=&quot;https://www.youtube-nocookie.com/embed/9I9GdSQ1bbM&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;This an opinionated transcription of a talk that &lt;a href=&quot;https://samnewman.io/&quot;&gt;Sam Newman&lt;/a&gt; has presented in the 2019 GOTO Conference, Berlin edition. There were several points on his presentation that, I think, were spot on and deserves to be transcribed and better explained. There is a bit of a debate about whether or not to start from a Monolith and then move to a Microservice Architecture. Understanding how &lt;i&gt;decomposing monolith&lt;/i&gt; might not only shed a light on this but also made us understand the benefits of doing it gradually.&lt;/p&gt;
&lt;/header&gt;

&lt;article class=&quot;timeline&quot;&gt;
    &lt;section&gt;
        &lt;time&gt;2:40&lt;/time&gt;
        &lt;h2&gt;Monolith&lt;/h2&gt;
        &lt;p&gt;Sam emphasises that Monolith Service is not the same as a Legacy System. In practice, they differ substantially and we need to observe them differently so we can deliver a better solution to our managers and customers.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;4:16&lt;/time&gt;
        &lt;h2&gt;Modular Monolith Deployment&lt;/h2&gt;
        &lt;p&gt;After introducing the basic concept of a Monolith, Newman quickly discusses Modular Monolith deployment. Architecture wise, its components are internally split into modules (depending on the language you use it can simply be packages, namespaces or libraries). These modules are using run on the same process and its persistence layer is usually centralized in a single database instance.&lt;/p&gt;
        &lt;p&gt;He believes &lt;i&gt;this is, in theory, a good scenario to be, as these modules can be easily split into smaller services later&lt;/i&gt;, reducing the effort to transition the service into a microservice. &quot;Most people are better of in a modular monolith deployment&quot; than in a microservice architecture - as he will discuss later.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;7:14&lt;/time&gt;
        &lt;h2&gt;Third-party Monolith&lt;/h2&gt;
        &lt;p&gt;Newman describes a third-party monolith as everything &quot;that is completely out of your control&quot;, something you can't change its internal behaviour. It might be your CRM software that your SaaS application relies on or even that old piece of software which you don't have the source code.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;8:01&lt;/time&gt;
        &lt;h2&gt;Distributed Monolith&lt;/h2&gt;
        &lt;p&gt;Distributed Monolith differs from a simple monolith by having its functionalities are split across different services, using the network to communicate with each other. Because of how we split our system apart, or even due to different reasons, we often end up having pieces of code being changed across module boundaries.&lt;/p&gt;
        &lt;p&gt;It is, arguably, the worst scenario you can be as the team who maintains it will have all the challenges a distributed system has along with the downsides of a monolith. It introduces a high cost to change functionalities, larger-scoped deployments and requires higher co-ordination activities - as you have more things that might go wrong.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;10:20&lt;/time&gt;
        &lt;blockquote&gt;
            &lt;p&gt;Fundamentally, you have to accept that monolith isn't necessarily the enemy - it's extremely rare that your goal is to kill the monolith. It sometimes happens but, most of the time, you're in a situation where you're trying to achieve something as a business but your current architecture won't let you achieve that goal.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;This is an important bit from his presentation and it needs to be transcribed as is. A Monolith Service by itself is not a bad thing and, like any other architectural decision, it has its pros and cons. We should only switch from a monolith to a microservice architecture when its benefits overcome the cost of maintaining a complex distributed system.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;12:44&lt;/time&gt;
        &lt;blockquote&gt;
            &lt;p&gt;You won't appreciate the true horror, pain and suffering of microservices until you're running then in production.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;Perhaps a good start might be extracting one module from your Modular Monolith into an external service. What you learn from observing this new service might give you enough insights to continue with the transition from a monolith to a microservice architecture.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;15:15&lt;/time&gt;
        &lt;h2&gt;Strangler Fig Pattern&lt;/h2&gt;
        &lt;p&gt;At this point in his presentation, Sam cut the chase and started to present solutions (architectural patterns) that will help us to decompose a monolith service. Strangler Fig is a pattern in which you wrap new functionalities around the existing ones in a way that the existing solution is not changed or is aware of it. In practical terms, he suggests us introduce an HTTP Proxy to intercept calls to the existing service diverting the calls to the new one as well.&lt;/p&gt;
        &lt;p&gt;The &lt;b&gt;Strangler Fit Pattern fits perfectly when we are at the beginning of the transition to a microservice or when dealing with Third-Party Monoliths&lt;/b&gt;, as other components of our existing solution still depend on the data managed by the one which will be replaced. The original component tables will still be fed with new data, giving us time to rethink or redesign other components in the future.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;22:04&lt;/time&gt;
        &lt;h2&gt;Branch By Abstraction&lt;/h2&gt;
        &lt;p&gt;Although his explanation about this pattern was good enough for a presentation in front of a big audience, I reckon his own definition (taken from &lt;a href=&quot;https://samnewman.io/patterns/architectural/branch-by-abstraction/&quot;&gt;his blog&lt;/a&gt;) wraps it up perfectly.&lt;/p&gt;
        &lt;blockquote&gt;
            &lt;p&gt;When making a significant change to how a piece of functionality is implemented, the challenge is how to work on this reimplementation over a period of time. With branch-by-abstraction, you create a single abstraction point over the functionality to be reimplemented, allowing both the existing functionality and the new implementation to co-exist inside the same running process at the same time.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;At this point in his presentation, he started to describe the ideal step-by-step to implement this pattern. I've modified it slightly to make it easier to reproduce.&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;&lt;b&gt;Isolate the current implementation&lt;/b&gt; - This is the first and most important and delicate step of this pattern, where you isolate the current implementation from the rest of the service. At this step you have to move the logic of the current functionality you intend to replace and move it to a single place (same package, module or folder).&lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Create an abstraction point&lt;/b&gt; - Create an interface that will behave as the contract to call that given functionality. With the &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;Liskov Substitution Principle&lt;/a&gt; in mind, you must make sure your software calls a default implementation of this internal, which will call your just isolated functionality.&lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Start working on the new service implementation&lt;/b&gt; - Once you finish, the new service will be later called by the monolith via HTTP (assuming that you exposed the new functionality through a Web API) and the web client should be wrapped in an alternative implementation of the just created interface.&lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Switch over when it is ready to release&lt;/b&gt; - &lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Clean up&lt;/b&gt; - Observe production and gather data to assess the results. A rollback is still possible at this point, allowing you to revisit the implementation until everything is working perfectly. Once everything is working as expected, you can remove the old functionality from your codebase.&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;26:07&lt;/time&gt;
        &lt;h2&gt;Parallel Run&lt;/h2&gt;
        &lt;p&gt;Being a variation of Branch by Abstraction, Parallel Run allows both implementations to co-exist at the same time. This is particularly useful to check if the behaviour has changed. Although both branches have different implementations it's expected that they to behave the same way, unless otherwise noted. Therefore, when comparing the outcome of both functionalities, it's important to take the original implementation as the source of truth, where any discrepancy in the result comparison between them should be considered a failure in the new service.&lt;/p&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;time&gt;28:10&lt;/time&gt;
        &lt;h2&gt;Accessing the Data&lt;/h2&gt;
        &lt;p&gt;Entering in the last stage of his talk, Sam finally addresses what he describes as the hardest topic when decomposing a monolith: how to organize and access the data on from/on the just created service. On his conception, on the evolutionary point of view, the data migration should be comprised by the following steps.&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;&lt;b&gt;Temporarily reuse the existing functionality database&lt;/b&gt; - Direct communication between the new service and the existing database would be allowed in as a temporary measure to stabilize the new functionality. Treating this as a permanent solution, though, might be the beginning of a new distributed monolith due to how tightly coupled both services became.&lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Expose the existing data via API&lt;/b&gt; - This solution is intended to reduce, but not remove, the coupling between both services. It gives developers more flexibility to react to possible changes that might happen in the database schema. He encourages us, though, to revisit the way information is consumed or ingested to avoid cyclic dependencies between both services - a common antipattern found in distributed monoliths.&lt;/li&gt;
            &lt;li&gt;&lt;b&gt;Move the data to the new service&lt;/b&gt; - Turning the new service into the source of truth is the definitive move to finish the migration from monolith to a microservice architecture. It comes with its challenges though. Joins between tables have to be rethought, split tables might be necessary and referential integrity provided by the database layer is completely off the table.&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/section&gt;
&lt;/article&gt;

&lt;h2&gt;Takeaways from talk&lt;/h2&gt;
&lt;p&gt;Newman did a brilliant job outlining the tradeoffs of prematurely adopting Microservice Architecture and I reckon there’s richness on his speech when he describes the dreadful consequences when we mistakenly end up creating a Distributed Monolith. Tackling the issues it introduces leads us to &lt;a href=&quot;https://github.com/korfuri/awesome-monorepo&quot;&gt;introduce new hacks in our architecture and deployment pipeline&lt;/a&gt;, like monorepo or shared modules between services. As Microservices are independently deployable - and generally speaking share no source code between them - our CI/CD is actually simpler. It is a good balance between cost and delivered value to our stakeholders.&lt;/p&gt;

&lt;p&gt;By reading between the lines we can also notice how much he is concerned about monitoring the runtime environment and tackle unexpected issues at early stages of its deployments. Due to the complexity of distributed systems, handling network and hardware issues before the business requirements make the software complex would save us several hours of development.&lt;/p&gt;</content><author><name></name></author><category term="engineering" /><category term="information architecture" /><category term="cost management" /><summary type="html">This an opinionated transcription of a talk that Sam Newman has presented in the 2019 GOTO Conference, Berlin edition. There were several points on his presentation that, I think, were spot on and deserves to be transcribed and better explained. There is a bit of a debate about whether or not to start from a Monolith and then move to a Microservice Architecture. Understanding how decomposing monolith might not only shed a light on this but also made us understand the benefits of doing it gradually.</summary></entry><entry><title type="html">Producing Professional Deliverables</title><link href="https://miere.observer/engineering/2020/04/20/Producing-professional-deliverables.html" rel="alternate" type="text/html" title="Producing Professional Deliverables" /><published>2020-04-20T00:00:00+10:00</published><updated>2020-04-20T00:00:00+10:00</updated><id>https://miere.observer/engineering/2020/04/20/Producing-professional-deliverables</id><content type="html" xml:base="https://miere.observer/engineering/2020/04/20/Producing-professional-deliverables.html">&lt;p&gt;When someone is described as a professional one might see that person as someone who does something for a living. Others might agree with the Cambridge dictionary, seeing professionals as those who have “[…] the type of job that needs a high level of education and training” &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. Perhaps we can all agree that the meaning of words evolves as time passes by - having its meaning adapted to suit a more recent context. Maybe “professional” in the modern days might’ve acquired different meaning from what it used to have in the past.&lt;/p&gt;

&lt;h2 id=&quot;the-need-for-consistency&quot;&gt;The need for consistency&lt;/h2&gt;
&lt;p&gt;Let’s take football players &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; for a moment. They only begun getting paid as professionals since last quarter of the 18th century &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; but when we compare the quality of the games back then with nowadays’, and we put nostalgia aside, the gap is huge. Pelé, Maradona, Zidane and Messi are historically regarded as those who took the game to the next level. But so did managers and coaches, “who dreamed up catenaccio and zonal marking and the sweeper system, all of it designed to stop the virtuosos showcasing their talents” &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The bar was raised to a point where we’ve been scoring less than a hundred years ago &lt;sup id=&quot;fnref:4:1&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;. While only a few players can keep up with their careers for more than 8 years &lt;sup id=&quot;fnref:4:2&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, most of them tend to retire quite early - especially if compared to a software engineer. In fact, the most successful footballers were those who had more &lt;strong&gt;consistent performance&lt;/strong&gt; in their teams.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Consistency&lt;/em&gt; is probably the most desirable skill I look for when I hire someone. Independently on how senior as an engineer you are, delivering consistent results means that I can predict how long it takes for you to finish your tasks, how many issues you might introduce in software and, how much effort should I put for you to reach the ideal performance within the team.&lt;/p&gt;

&lt;p&gt;The more senior you are the fewer issues you might introduce, the faster you can learn and adopt a new technique and the more adaptable you are to tackle problems you’ve never faced before. But, if you don’t master the techniques you’ve learned before in a way that you produce consistent results, your seniority might be easily replaceable by a junior. Think about it, if you can learn consistently, the more I teach you the more improvement I can see on your deliverables. On the other hand, a non-consistent senior developer might learn something new and put it in practice straight away but may struggle to use it under a different scenario as he hasn’t trained long enough to master his new skill.&lt;/p&gt;

&lt;h2 id=&quot;reproducibility-is-key&quot;&gt;Reproducibility is key&lt;/h2&gt;
&lt;p&gt;If we go a few centuries back, we would see craft workers (such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Artisan&quot;&gt;Artisans&lt;/a&gt;) in action, perhaps the contemporary version of the Software Engineer as we know it &lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. A skilled craft worker creates material objects partly or entirely by hand. Artisans were the dominant producers of consumer products before the Industrial Revolution. Once passed through the career chain from apprentice to journeyman, he could be elected to become a master craftsman, enjoying one of the highest social statuses in their communities at the time. &lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The success of the &lt;a href=&quot;https://en.wikipedia.org/wiki/British_Agricultural_Revolution&quot;&gt;Agricultural Revolution&lt;/a&gt; of the 18th century created a favourable climate for industrialization. With increasing production of food, the British population could be fed at lower prices with less effort than ever before. The surplus of food meant that British families &lt;a href=&quot;https://study.com/academy/lesson/causes-of-the-first-industrial-revolution.html&quot;&gt;could use the money they saved to purchase manufactured goods&lt;/a&gt;. Under given circumstances, it’s easy to understand that craft workers weren’t enough to cope with the higher demand for goods that were needed.&lt;/p&gt;

&lt;p&gt;Just as the demand for consistent and reliable delivered goods ended up replacing artisans with machines, &lt;span class=&quot;highlight&quot;&gt;the overwhelming demand for value to be provided by the current software industry will also raise the bar&lt;/span&gt; in a way that Software Engineers who lack precision, predictability or measurement won’t make it far in their careers.&lt;/p&gt;

&lt;p&gt;To better understand this idea, let’s assume a developer was elected by his team to design a microservice from scratch. On his team, there’s no one in charge of the infrastructure or taking macro architectural decisions. A good outcome from this project might be big deal for his reputation, especially if no one else has to worry about bugs if there’s a brief README file explaining how to run the software locally and releasing a new version of it is just a matter of having a Pull Request approved.&lt;/p&gt;

&lt;p&gt;One might argue that taking care of all of these details consumes valuable time that would be better spent implementing new features. But I dread the days when I had to stop what I was doing to answer questions from my colleagues when they have to maintain a software I’ve previously written without proper documentation. Eventually, I realized that when the README file is good enough I have fewer interruptions. When my unit tests cover most of - if not all - the source code, I have fewer bugs to fix and hence have more time to create something new.&lt;/p&gt;

&lt;p&gt;A wise engineer, though, may go even further and streamline his knowledge in a way that can be easily reproducible as well. What if a Kotlin developer has &lt;a href=&quot;https://github.com/Skullabs/kos-sample-gradle&quot;&gt;a small Gradle project&lt;/a&gt; on his Github account? Why don’t we create &lt;a href=&quot;https://github.com/miere/terraform-aws-fargate-ha-web&quot;&gt;a module to deploy our software using Docker&lt;/a&gt;? Wouldn’t it be useful if you save that &lt;a href=&quot;https://github.com/miere/terraw&quot;&gt;small script&lt;/a&gt; that automates everything you need to run your terraform scripts? If designing software is the main part of your job, perhaps you should figure out a way to reproduce the boring tasks as quickly as possible when the necessity comes up you will be able to deliver a masterpiece much faster than anyone else.&lt;/p&gt;

&lt;h2 id=&quot;going-beyond-kents-simple-design&quot;&gt;Going beyond Kent’s Simple Design&lt;/h2&gt;
&lt;p&gt;Speaking of masterpieces, in the 1990s Kent Beck introduced The Four Elements of Simple Design, a principle that would be later immortalised in his &lt;a href=&quot;https://www.amazon.com/gp/product/0201616416&quot;&gt;book Extreme Programming Explained&lt;/a&gt;. He states these rules as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Runs all the tests&lt;/li&gt;
  &lt;li&gt;Has no duplicated logic. Be wary of hidden duplication like parallel class hierarchies&lt;/li&gt;
  &lt;li&gt;States every intention important to the programmer&lt;/li&gt;
  &lt;li&gt;Has the fewest possible classes and methods&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;His rules were written in priority order, where the ones at the top take priority over the following ones. It comes as no surprise that, if you can’t afford the time to have all of it, he would like you to put more effort into tests. Being behind the roots of unit testing frameworks we have nowadays &lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;, the author of &lt;a href=&quot;https://en.wikipedia.org/wiki/SUnit&quot;&gt;SUnit&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Kent_Beck&quot;&gt;co-authoring&lt;/a&gt; JUnit with Erich Gamma, he’s an avid advocate of testing as feedback tool &lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;, something you can read from the man itself on his award-winning book &lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt; &lt;a href=&quot;https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530/&quot;&gt;Test-Driven Development by Example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take the popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC pattern&lt;/a&gt; to draw a comparison with Beck’s rules. Between the late 2000s and early 2010s, MVC was considered the &lt;em&gt;silver bullet pattern&lt;/em&gt; for his adopters &lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;. In an era where nobody was actually concerned about &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of Concerns&lt;/a&gt; and the front-end was mostly rendered by the backend, it was indeed quite convenient to grow your software by simply placing classes in one of its three buckets. Despite its convenience, not all software designed mostly using MVC (from end-to-end) is easy to maintain, once it grows bigger the need for new features to be included urges us to adopt different approaches - a phenomenon well described by Meir Lehman &lt;a href=&quot;https://ieeexplore.ieee.org/document/1456074&quot;&gt;in another master piece&lt;/a&gt; &lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Kent’s rules, on the other hand, are distinguished from other methodologies by focusing on the &lt;em&gt;outcome you might have&lt;/em&gt; instead of &lt;em&gt;how one has to organize his code&lt;/em&gt;. It is benefit-driven, encouraging you to adopt whatever strategy you have in your playbook as long as you respect those outcomes. As a result, maintainability and fast feedback on breaking changes will be the benefits those who adopt it will be rewarded with. That’s the actual mindset a professional has that to keeps the &lt;strong&gt;quality&lt;/strong&gt; of their deliverables higher than the average.&lt;/p&gt;

&lt;p&gt;Since it’s been more than 2 decades since these rules have been crafted, if you allow me, I’d like to respectfully include a couple of items that I think should be mandatory for any professional delivery in software.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;It should be possible to run all your tests with a single (yet simple) command.&lt;/li&gt;
  &lt;li&gt;It should be possible to run your software with a single (yet simple) command.&lt;/li&gt;
  &lt;li&gt;It should be possible to package your software with a single (yet simple) command.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While these 3 rules I’m introducing might be seen as silly at first glance, it makes perfect sense when you need to handover your deliverable to someone else. Just as Beck’s rules, they’ve been ordered by priority as well, thus, if you can’t afford to have all of them, just make sure one can painlessly run all tests and check for regressions on your software. The last two rules are somewhat related, as you need to package your software to run it locally. Thoroughly reviewing all the dependencies (libraries, tools, and dependent services) your service relies on are &lt;a href=&quot;https://dzone.com/articles/learn-how-to-setup-a-cicd-pipeline-from-scratch&quot;&gt;the foundation to have a hassle free CI/CD setup process&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;takeaways&quot;&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;Professionalism is a quite subjective topic, but it worth keeping in mind that we’re living in a different world where the current standards of our industry expect higher delivery pace, and less time spent on bugs or amending poorly developed features. Even complex structures have been shrewdly discouraged. In fact, managers are going one step further in this direction, trying their best to reduce the learning curve when developers jump in to maintain a different microservice, independently from whether the developer is a newcomer or a long-time hero within the company &lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;If I could sum up the aforementioned topics, I’d say the Professional Software Engineer from nowadays should be consistently capable of delivering high-quality software in a way that anyone with the source code could maintain it with no hassle.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Special thanks to &lt;a href=&quot;https://www.linkedin.com/in/gabrielsjacques/&quot;&gt;Gabriel Jacques&lt;/a&gt;, Ricardo Baumgartner and &lt;a href=&quot;http://vnaik.com&quot;&gt;Varun Naik&lt;/a&gt; for their contributions.&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://dictionary.cambridge.org/dictionary/english/professional&quot;&gt;Cambrige dictionary’s definition of the word “professional”&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Football_player&quot;&gt;Football&lt;/a&gt;, also known as soccer for the Americans &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fergus_Suter&quot;&gt;Fergus Suter&lt;/a&gt; was arguably the first recognised professional footballer. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;Instead of the consistent and insistent downward trend in goals we have seen over a century and a half of play, in the last 60 years or so there appears to be a levelling off. Goals are not dying. They are plateauing. Scoring has remained essentially stable in the last two decades, perhaps even as far back as the 1970s. See: &lt;a href=&quot;https://slate.com/culture/2013/08/the-numbers-game-why-soccer-teams-score-fewer-goals-than-they-did-100-years-ago.html&quot;&gt;The Great Leveling&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:4:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:4:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot;&gt;
      &lt;p&gt;In fact, there’s a whole movement in which developers describe themselves as Software Craftsman. Perhaps the best description of how Software Engineering became more relevant in the field can be found in &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_craftsmanship&quot;&gt;this article&lt;/a&gt; in Wikipedia. &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;See &lt;em&gt;History of Western Civilization&lt;/em&gt; at Boise State University’s &lt;a href=&quot;https://web.archive.org/web/20090107061228/http://history.boisestate.edu/westciv/medsoc/23.shtml&quot;&gt;“Document No.23”&lt;/a&gt;. Archived from the &lt;a href=&quot;http://history.boisestate.edu/westciv/medsoc/23.shtml&quot;&gt;original&lt;/a&gt; on 2009-01-07. Retrieved 2009-01-08. &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:9&quot;&gt;
      &lt;p&gt;Kent Bech is often cast as the mind that leads to the &lt;a href=&quot;https://en.wikipedia.org/wiki/XUnit&quot;&gt;xUnit&lt;/a&gt; frameworks being widely adopted. &lt;a href=&quot;#fnref:9&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://medium.com/@kentbeck_7670/programmer-test-principles-d01c064d7934&quot;&gt;According to Beck&lt;/a&gt;, “Programmer tests are an oracle providing feedback coding-decision-by-coding-decision”. &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:10&quot;&gt;
      &lt;p&gt;Co-authored by Addison-Wesley, the book is award-winning of the Jolt Productivity Award. &lt;a href=&quot;#fnref:10&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:11&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://twitter.com/miere/status/14496627913924608&quot;&gt;Here&lt;/a&gt; is a discussion (in PT_BR) back in 2010 I had on Twitter about this very topic, showing how heated a conversation can get when enquiring MVC developers about MVC replacements. At the time, I was under heavy training by &lt;a href=&quot;https://twitter.com/anielson&quot;&gt;one of my previous mentors&lt;/a&gt;, as he noticed my knowledge was mostly focused on hardware and low-level software development neglecting common design patterns. &lt;a href=&quot;#fnref:11&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:12&quot;&gt;
      &lt;p&gt;In 1974, Lehman stated in his book that “as an E-type system evolves, its complexity increases unless work is done to maintain or reduce it”. &lt;a href=&quot;#fnref:12&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:13&quot;&gt;
      &lt;p&gt;It worth read about &lt;a href=&quot;https://hbr.org/2014/01/how-netflix-reinvented-hr&quot;&gt;how Netflix reinvented the way they manage their teams&lt;/a&gt;, what are their expectations and for how long they’ve decided to invest and quality and reproducibility on their teams to avoid rework and spend more time on what will have higher return of investment. &lt;a href=&quot;#fnref:13&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="engineering" /><category term="master" /><summary type="html">When someone is described as a professional one might see that person as someone who does something for a living. Others might agree with the Cambridge dictionary, seeing professionals as those who have “[…] the type of job that needs a high level of education and training” 1. Perhaps we can all agree that the meaning of words evolves as time passes by - having its meaning adapted to suit a more recent context. Maybe “professional” in the modern days might’ve acquired different meaning from what it used to have in the past. Cambrige dictionary’s definition of the word “professional” &amp;#8617;</summary></entry></feed>